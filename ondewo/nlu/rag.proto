// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Modifications Copyright 2020-2023 ONDEWO GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// File-level comment for <code>ondewo/nlu/rag.proto</code>.
// This file contains a single service <a href="#ondewo.nlu.Rags">Rags</a>. The Rags service provides integration with RAGFlow for Retrieval-Augmented Generation (RAG), including dataset management, document processing, chunk retrieval, conversational AI with chat and agent assistants, and file management. Key message types include <a href="#ondewo.nlu.RagDataset">RagDataset</a>, <a href="#ondewo.nlu.RagChat">RagChat</a>, and <a href="#ondewo.nlu.RagAgent">RagAgent</a>.
syntax = "proto3";

package ondewo.nlu;

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";

// TODO change Github link if changes to RAGFlow are merged to upstream

// Provides an interface for interacting with the RAGFlow RAG engine.
// Covers all endpoints of the <a href="https://github.com/ondewo/ragflow">RAGFlow</a> HTTP API. For more information on RAGFlow refer to the <a href="https://ragflow.io/docs/dev/">official documentation</a>
service Rags {

    // ===========================================
    // Dataset Management (10 methods)
    // REST: /api/v1/datasets
    // ===========================================

    // RAGFlow endpoint: POST /api/v1/datasets

    // Create a new dataset (knowledge base).<br>
    // Uses tenant's default embedding model if not specified.
    rpc RagCreateDataset(RagCreateDatasetRequest) returns (RagDataset);

    // RAGFlow endpoint: PUT /api/v1/datasets/<dataset_id>

    // Update an existing dataset's configuration.<br>
    // Cannot change embedding_model if dataset has chunks.
    rpc RagUpdateDataset(RagUpdateDatasetRequest) returns (RagDataset);

    // RAGFlow endpoint: DELETE /api/v1/datasets

    // Delete one or more datasets (batch operation).<br>
    // If ids is null or empty, deletes all user's datasets.<br>
    // Deletes all associated documents, files, and chunks.
    rpc RagDeleteDatasets(RagDeleteRequest) returns (RagPartialSuccess);

    // RAGFlow endpoint: GET /api/v1/datasets

    // List datasets with pagination and filtering.<br>
    // Returns datasets from all tenants the user has access to.
    rpc RagListDatasets(RagListDatasetsRequest) returns (RagDatasetList);

    // RAGFlow endpoint: GET /api/v1/datasets/<dataset_id>/knowledge_graph

    // Get the knowledge graph for a dataset.<br>
    // Returns graph structure with nodes (max 256) and edges (max 128).
    rpc RagGetKnowledgeGraph(RagDatasetIdRequest) returns (RagGetKnowledgeGraphResponse);

    // RAGFlow endpoint: DELETE /api/v1/datasets/<dataset_id>/knowledge_graph

    // Delete the knowledge graph for a dataset.<br>
    // Deletes graph-related chunks but not the dataset itself.
    rpc RagDeleteKnowledgeGraph(RagDatasetIdRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: POST /api/v1/datasets/<dataset_id>/run_graphrag

    // Construct a knowledge graph for a dataset.<br>
    // Uses the dataset's GraphRAG settings.
    rpc RagConstructKnowledgeGraph(RagDatasetIdRequest) returns (RagConstructKnowledgeGraphResponse);

    // RAGFlow endpoint: GET /api/v1/datasets/<dataset_id>/trace_graphrag

    // Get the knowledge graph construction status of a dataset.
    rpc RagKnowledgeGraphStatus(RagDatasetIdRequest) returns (RagTaskStatus);

    // RAGFlow endpoint: POST /api/v1/datasets/<dataset_id>/run_raptor

    // Construct a RAPTOR for a dataset.<br>
    // Uses the dataset's RAPTOR settings.
    rpc RagConstructRaptor(RagDatasetIdRequest) returns (RagConstructRaptorResponse);

    // RAGFlow endpoint: GET /api/v1/datasets/<dataset_id>/trace_raptor

    // Get the RAPTOR construction status of a dataset.
    rpc RagRaptorStatus(RagDatasetIdRequest) returns (RagTaskStatus);

    // ========================================================================
    // Document Management (5 methods)
    // REST: /api/v1/datasets/<dataset_id>/documents
    // ========================================================================

    // RAGFlow endpoint: POST /api/v1/datasets/<dataset_id>/documents

    // Upload one or more documents to a dataset.<br>
    // Documents start in UNSTART state and must be parsed.
    rpc RagUploadDocuments(stream RagUploadDocumentsRequest) returns (RagDocumentList);

    // RAGFlow endpoint: PUT /api/v1/datasets/<dataset_id>/documents/<document_id>

    // Update document metadata and configuration.<br>
    // Changing chunk_method resets document to UNSTART and deletes chunks.
    rpc RagUpdateDocument(RagUpdateDocumentRequest) returns (RagDocument);

    // RAGFlow endpoint: GET /api/v1/datasets/<dataset_id>/documents/<document_id>

    // Download the original document file.<br>
    // Returns binary file stream from storage.<br>
    // First chunk contains metadata, subsequent chunks only contain data.
    rpc RagDownloadDocument(RagDownloadDocumentRequest) returns (stream RagFileChunk);

    // RAGFlow endpoint: GET /api/v1/datasets/<dataset_id>/documents

    // List documents in a dataset with pagination and filtering.<br>
    // Supports time range filtering and keyword search.
    rpc RagListDocuments(RagListDocumentsRequest) returns (RagListDocumentsResponse);

    // RAGFlow endpoint: DELETE /api/v1/datasets/<dataset_id>/documents

    // Delete one or more documents from a dataset (batch operation).<br>
    // If ids empty, deletes all documents. Removes chunks and storage files.
    rpc RagDeleteDocuments(RagDeleteDocumentsRequest) returns (RagPartialSuccess);

    // ========================================================================
    // Chunk Management (7 methods)
    // REST: /api/v1/datasets/<dataset_id>/chunks, /api/v1/datasets/<dataset_id>/documents/<document_id>/chunks, /api/v1/retrieval
    // ========================================================================

    // RAGFlow endpoint: POST /api/v1/datasets/<dataset_id>/chunks

    // Start parsing documents into chunks.<br>
    // Cannot parse documents currently being processed (0 < progress < 1).<br>
    // Queues documents for background processing.
    rpc RagParseDocuments(RagParseDocumentsRequest) returns (RagPartialSuccess);

    // RAGFlow endpoint: DELETE /api/v1/datasets/<dataset_id>/chunks

    // Stop parsing documents.<br>
    // Can only stop documents with progress between 0 and 1.
    rpc RagStopParsing(RagStopParsingRequest) returns (RagPartialSuccess);

    // RAGFlow endpoint: GET /api/v1/datasets/<dataset_id>/documents/<document_id>/chunks

    // List chunks of a document with pagination.<br>
    // Supports keyword search with content highlighting.
    rpc RagListChunks(RagListChunksRequest) returns (RagListChunksResponse);

    // RAGFlow endpoint: POST /api/v1/datasets/<dataset_id>/documents/<document_id>/chunks

    // Manually add a chunk to a document.<br>
    // Automatically tokenizes content and generates embeddings.
    rpc RagAddChunk(RagAddChunkRequest) returns (RagAddChunkResponse);

    // RAGFlow endpoint: DELETE /api/v1/datasets/<dataset_id>/documents/<document_id>/chunks

    // Remove one or more chunks from a document.<br>
    // If chunk_ids empty, removes all chunks from document.
    rpc RagRemoveChunks(RagRemoveChunksRequest) returns (RagPartialSuccess);

    // RAGFlow endpoint: PUT /api/v1/datasets/<dataset_id>/documents/<document_id>/chunks/<chunk_id>

    // Update an existing chunk's content and metadata.<br>
    // Re-tokenizes content and re-generates embeddings if content changed.
    rpc RagUpdateChunk(RagUpdateChunkRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: POST /api/v1/retrieval

    // Retrieve chunks using vector similarity search.<br>
    // All datasets must use the same embedding model.<br>
    // Supports reranking, metadata filtering, and knowledge graph retrieval.
    rpc RagRetrieval(RagRetrievalRequest) returns (RagRetrievalResponse);

    // ========================================================================
    // File Management (11 methods)
    // REST: /api/v1/file
    // ========================================================================

    // RAGFlow endpoint: POST /api/v1/file/upload

    // Upload one or more files via multipart form data.<br>
    // Supports nested folder paths in filename.<br>
    // Auto-creates intermediate folders.
    rpc RagUploadFiles(stream RagUploadFilesRequest) returns (RagFileList);

    // RAGFlow endpoint: POST /api/v1/file/create

    // Create a new file or folder.<br>
    // Duplicate names in same folder not allowed.
    rpc RagCreateFile(RagCreateFileRequest) returns (RagFile);

    // RAGFlow endpoint: GET /api/v1/file/list

    // List files in a folder with pagination.<br>
    // Supports keyword search. Auto-initializes knowledgebase docs folder.
    rpc RagListFiles(RagListFilesRequest) returns (RagListFilesResponse);

    // RAGFlow endpoint: GET /api/v1/file/root_folder

    // Get user's root folder information.<br>
    // Each tenant has a unique root folder.
    rpc RagGetRootFolder(RagGetRootFolderRequest) returns (RagGetRootFolderResponse);

    // RAGFlow endpoint: GET /api/v1/file/parent_folder

    // Get the parent folder of a file.<br>
    // Returns 404 if file or parent not found.
    rpc RagGetParentFolder(RagFileIdRequest) returns (RagGetParentFolderResponse);

    // RAGFlow endpoint: GET /api/v1/file/all_parent_folder

    // Get all parent folders (breadcrumb path) of a file.<br>
    // Returns array from file itself to root (includes the file, ordered deepest to root).
    rpc RagGetAllParentFolders(RagFileIdRequest) returns (RagParentFoldersList);

    // RAGFlow endpoint: POST /api/v1/file/rm

    // Delete one or more files/folders (hard delete).<br>
    // Recursively deletes folder contents. Removes from storage.
    rpc RagDeleteFiles(RagDeleteFilesRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: POST /api/v1/file/rename

    // Rename a file or folder.<br>
    // Cannot change file extension. Duplicate names not allowed.
    rpc RagRenameFile(RagRenameFileRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: GET /api/v1/file/get/<file_id>

    // Download a file.<br>
    // Retrieves from MinIO/S3 storage.<br>
    // First chunk contains metadata, subsequent chunks only contain data.
    rpc RagDownloadFile(RagFileIdRequest) returns (stream RagFileChunk);

    // RAGFlow endpoint: POST /api/v1/file/mv

    // Move one or more files to another folder.<br>
    // Validates all files and destination exist.
    rpc RagMoveFile(RagMoveFileRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: POST /api/v1/file/convert

    // Convert files to documents and add to datasets.<br>
    // Handles folders recursively (converts all inner files).<br>
    // Links files to multiple datasets if multiple dataset_ids provided.
    rpc RagFileToDocument(RagFileToDocumentRequest) returns (RagFileToDocumentList);

    // ========================================================================
    // Chat Assistant Management (4 methods)
    // Chat assistants are RAG-powered conversational agents.
    // REST: /api/v1/chats
    // ========================================================================

    // RAGFlow endpoint: POST /api/v1/chats

    // Create a new chat assistant.<br>
    // All datasets must have parsed files (chunk_num > 0).<br>
    // All datasets must use the same embedding model.
    rpc RagCreateChatAssistant(RagCreateChatAssistantRequest) returns (RagChatAssistant);

    // RAGFlow endpoint: PUT /api/v1/chats/<chat_id>

    // Update an existing chat assistant's configuration.<br>
    // LLM and prompt configs are merged with existing values.
    rpc RagUpdateChatAssistant(RagUpdateChatAssistantRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: DELETE /api/v1/chats

    // Delete one or more chat assistants (batch operation).<br>
    // If ids empty, deletes all user's chats (soft delete).
    rpc RagDeleteChatAssistants(RagDeleteRequest) returns (RagPartialSuccess);

    // RAGFlow endpoint: GET /api/v1/chats

    // List chat assistants with pagination.<br>
    // Returns full dataset objects (not just IDs).
    rpc RagListChatAssistants(RagListChatAssistantsRequest) returns (RagChatAssistantList);

    // ========================================================================
    // Agent Management (4 methods)
    // REST: /api/v1/agents
    // ========================================================================

    // RAGFlow endpoint: POST /api/v1/agents

    // Create a new agent with DSL configuration.<br>
    // Title must be unique for the user.
    rpc RagCreateAgent(RagCreateAgentRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: PUT /api/v1/agents/<agent_id>

    // Update an existing agent.<br>
    // DSL updates create new version snapshot. Only owner can update.
    rpc RagUpdateAgent(RagUpdateAgentRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: DELETE /api/v1/agents/<agent_id>

    // Delete an agent (hard delete).<br>
    // Only owner can delete.
    rpc RagDeleteAgent(RagDeleteAgentRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: GET /api/v1/agents

    // List agents with pagination.<br>
    // Only returns user's own agents.
    rpc RagListAgents(RagListAgentsRequest) returns (RagAgentList);

    // ========================================================================
    // Session Management (6 methods)
    // REST: /api/v1/chats/<chat_id>/sessions, /api/v1/agents/<agent_id>/sessions
    // ========================================================================

    // RAGFlow endpoint: POST /api/v1/chats/<chat_id>/sessions

    // Create a new chat session (conversation).<br>
    // Session initialized with assistant's prologue message.
    rpc RagCreateChatSession(RagCreateChatSessionRequest) returns (RagChatSession);

    // RAGFlow endpoint: PUT /api/v1/chats/<chat_id>/sessions/<session_id>

    // Update a chat session's metadata (name only).<br>
    // Cannot update message or reference fields.
    rpc RagUpdateChatSession(RagUpdateChatSessionRequest) returns (google.protobuf.Empty);

    // RAGFlow endpoint: GET /api/v1/chats/<chat_id>/sessions

    // List sessions for a chat assistant.<br>
    // Returns message history with embedded chunk references.
    rpc RagListChatSessions(RagListChatSessionsRequest) returns (RagChatSessionList);

    // RAGFlow endpoint: DELETE /api/v1/chats/<chat_id>/sessions

    // Delete one or more chat sessions (batch operation).<br>
    // If ids empty, deletes all sessions for the chat (hard delete).
    rpc RagDeleteChatSessions(RagDeleteChatSessionsRequest) returns (RagPartialSuccess);

    // RAGFlow endpoint: GET /api/v1/agents/<agent_id>/sessions

    // List sessions for an agent.<br>
    // Can optionally exclude DSL from response for performance.
    rpc RagListAgentSessions(RagListAgentSessionsRequest) returns (RagAgentSessionList);

    // RAGFlow endpoint: DELETE /api/v1/agents/<agent_id>/sessions

    // Delete one or more agent sessions (batch operation).<br>
    // If ids empty, deletes all sessions for the agent (hard delete).
    rpc RagDeleteAgentSessions(RagDeleteAgentSessionsRequest) returns (RagPartialSuccess);

    // ========================================================================
    // Completion (4 methods)
    // REST: /api/v1/chats/<id>/completions, /api/v1/agents/<id>/completions, /api/v1/sessions
    // ========================================================================

    // RAGFlow endpoint: POST /api/v1/chats/<chat_id>/completions

    // Generate chat completion with RAG (server streaming).<br>
    // Creates new session if session_id not provided.
    rpc RagChatCompletion(RagChatCompletionRequest) returns (stream RagChatCompletionResponse);

    // RAGFlow endpoint: POST /api/v1/agents/<agent_id>/completions

    // Generate agent completion (server streaming).<br>
    // Filters events to only return message-related events.
    rpc RagAgentCompletion(RagAgentCompletionRequest) returns (stream RagAgentCompletionResponse);

    // RAGFlow endpoint: POST /api/v1/sessions/ask

    // Ask a question across datasets without a chat assistant.<br>
    // Streaming only. All datasets must have parsed files.
    rpc RagAsk(RagAskRequest) returns (stream RagAskResponse);

    // RAGFlow endpoint: POST /api/v1/sessions/related_questions

    // Generate related search terms for a question.<br>
    // Returns 5-10 suggestions considering industry context.
    rpc RagRelatedQuestions(RagRelatedQuestionsRequest) returns (RagRelatedQuestionsResponse);
}

// ============================================================================
// Common Types
// Shared types used across multiple services.
// ============================================================================

// Pagination parameters for list requests.
message RagPagination {

    // Optional. Page number (1-indexed, default: 1).
    int32 page = 1;

    // Optional. Number of items per page (default varies by endpoint).
    int32 page_size = 2;
}

// File metadata for streaming uploads/downloads.
message RagFileMetadata {

    // Required. Filename. Maximum length 255.
    string file_name = 1;

    // Optional. MIME type (e.g., <code>"application/pdf"</code>, <code>"image/png"</code>).
    string content_type = 2;

    // Optional. File size in bytes (if known, 0 if unknown).
    int64 size = 3;
}

// File chunk for streaming downloads.<br>
// First chunk contains metadata, subsequent chunks only contain data.
message RagFileChunk {

    // Optional. Chunk of file content.
    bytes data = 1;

    // Optional. File metadata (only in first chunk).
    RagFileMetadata metadata = 2;
}

// Upload chunk for streaming uploads.
// Used to stream file data after metadata is sent in first message.
message RagUploadChunk {

    // Required. Not actually optional but `optional` keyword is needed to enable presence tracking.
    // Without it, it is impossible to distinguish between `0` and not present.
    // Index into metadata.files array (0-based).
    optional int32 file_index = 1;

    // Optional. Chunk of file content, null indicates EOF.
    bytes data = 2;
}

// On complete success: no fields set (empty message).
// On partial success/failure: both fields set.
message RagPartialSuccess {

    // Number of successful operations.
    int32 success_count = 1;

    // Error messages for failed operations.
    repeated string errors = 2;
}

// ============================================================================
// Dataset Management Types
// ============================================================================


// Request message for creating a new dataset.
message RagCreateDatasetRequest {

    // Required. The agent to create the dataset for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Unique name of the dataset to create. Must follow these requirements:
    // <ul>
    //     <li>contain only characters from the basic multilingual Unicode plane</li>
    //     <li>maximum 128 characters</li>
    //     <li>case-insensitive</li>
    // </ul>
    string name = 2;

    // Optional. Dataset description. Maximum 65,535 characters.
    string description = 3;

    // Optional. Base64-encoded avatar image in the format <code>"data:image/[png|jpeg];base64,&lt;base64_string&gt;"</code>. Maximum 65,535 characters.
    string avatar = 4;

    // Optional. Access permission for new dataset.
    RagPermission permission = 5;

    // Optional. Default chunking method for documents in this dataset.
    RagChunkMethod chunk_method = 6;

    // Optional. Configuration settings for the dataset parser. The used fields vary depending on the selected <code>chunk_method</code>.
    RagParserConfig parser_config = 7;

    // Optional. Embedding model name in the format "&lt;model_name&gt;@&lt;factory_name&gt;" (uses user's default if not specified). Maximum length 255.
    string embedding_model = 8;
}

// Access permissions for a dataset.
enum RagPermission {

    // Only the current user can manage the dataset (default).
    me = 0;

    // All team members of the current user can manage the dataset.
    team = 1;
}

// Chunking method for documents. See <a href="https://ragflow.io/docs/dev/configure_knowledge_base#select-chunking-method">https://ragflow.io/docs/dev/configure_knowledge_base#select-chunking-method</a> for details.
enum RagChunkMethod {

    // General (default).
    naive = 0;

    // Book.
    book = 1;

    // Email.
    email = 2;

    // Laws.
    laws = 3;

    // Manual.
    manual = 4;

    // One.
    one = 5;

    // Paper.
    paper = 6;

    // Picture.
    picture = 7;

    // Presentation.
    presentation = 8;

    // Q&A.
    qa = 9;

    // Table.
    table = 10;

    // Tag.
    tag = 11;
}

// Document parser configuration.
//
// Used fields depend on the chunking method of the document.
// <ul>
//     <li><code>naive</code>: uses the following fields (all optional)</li>
//     <ul>
//         <li><code>auto_keywords</code></li>
//         <li><code>auto_questions</code></li>
//         <li><code>chunk_token_num</code></li>
//         <li><code>delimiter</code></li>
//         <li><code>html4excel</code></li>
//         <li><code>layout_recognize</code></li>
//         <li><code>tag_kb_ids</code></li>
//         <li><code>task_page_size</code></li>
//         <li><code>raptor</code></li>
//         <li><code>graphrag</code></li>
//     </ul>
//     <li><code>qa</code>, <code>manual</code>, <code>paper</code>, <code>book</code>, <code>laws</code>, <code>presentation</code>: uses only the <code>raptor</code> field</li>
//     <li><code>table</code>, <code>picture</code>, <code>one</code>, <code>email</code>: does not use any field (expects empty message)</li>
// </ul>
message RagParserConfig {

    // Optional. Minimum 0, maximum 32, default 0. See <a href="https://ragflow.io/docs/dev/autokeyword_autoquestion">https://ragflow.io/docs/dev/autokeyword_autoquestion</a> for details.
    int32 auto_keywords = 1;

    // Optional. Minimum 0, maximum 10, default 0. See <a href="https://ragflow.io/docs/dev/autokeyword_autoquestion">https://ragflow.io/docs/dev/autokeyword_autoquestion</a> for details.
    int32 auto_questions = 2;

    // Optional. Minimum 1, maximum 2048, default 512.
    int32 chunk_token_num = 3;

    // Optional. Default <code>"\n"</code>.
    string delimiter = 4;

    // Optional. Convert Excel documents to HTML. Default <code>false</code>.
    bool html4excel = 5;

    // Optional. Default <code>"DeepDOC"</code>.
    string layout_recognize = 6;

    // Optional. List of dataset IDs. See <a href="https://ragflow.io/docs/dev/use_tag_sets">https://ragflow.io/docs/dev/use_tag_sets</a> for details.
    repeated string tag_kb_ids = 7;

    // Optional. Minimum 1. Maximum 10. Default 1.
    int32 topn_tags = 8;

    // Optional. Minimum 0.0. Maximum 1.0. Default 0.1.
    float filename_embd_weight = 9;

    // Optional. Minimum 1, default 12. Only applies to PDFs.
    int32 task_page_size = 10;

    // Optional. RAPTOR-specific settings. Default <code>{ "use_raptor": false }</code>.
    RagRaptorConfig raptor = 11;

    // Optional. GRAPHRAG-specific settings. Default <code>{ "use_graphrag": false }</code>.
    RagGraphRagConfig graphrag = 12;
}

// RAPTOR configuration. Refer to <a href="https://arxiv.org/html/2401.18059v1">RAPTOR paper</a> for more information about RAPTOR.
message RagRaptorConfig {

    // Optional. Default <code>false</code>. Whether to use RAPTOR for this dataset.
    bool use_raptor = 1;

    // Optional. Prompt to use for RAPTOR. Default:<br>
    // <code>"Please summarize the following paragraphs. Be careful with the numbers, do not make things up. Paragraphs as following:\n      {cluster_content}\nThe above is the content you need to summarize."</code>
    string prompt = 2;

    // Optional. Minimum 1. Maximum 2048. Default 256.
    int32 max_token = 3;

    // Optional. Minimum 0.0. Maximum 1.0. Default 0.1.
    float threshold = 4;

    // Optional. Minimum 1. Maximum 1024. Default 64.
    int32 max_cluster = 5;

    // Optional. Minimum 0. Default 0.
    int64 random_seed = 6;
}

// GraphRAG configuration.
message RagGraphRagConfig {

    // Optional. Default <code>false</code>.
    bool use_graphrag = 1;

    // Optional. Default <code>["organization", "person", "geo", "event", "category"]</code>.
    repeated string entity_types = 2;

    // Optional. Default <code>light</code>.
    RagGraphRagMethod method = 3;

    // Optional. Default <code>false</code>.
    bool community = 4;

    // Optional. Default <code>false</code>.
    bool resolution = 5;
}

// Knowledge graph construction methods.
enum RagGraphRagMethod {

    // Use prompts provided by <a href="https://github.com/HKUDS/LightRAG">LightRAG</a>.
    light = 0;

    // Use prompts provided by <a href="https://github.com/microsoft/graphrag">GraphRAG</a>.
    general = 1;
}

// Dataset containing documents for RAG.
message RagDataset {

    // Dataset UUID.
    string id = 1;

    // Base64-encoded avatar image.
    string avatar = 2;

    // RAGFlow Tenant ID.
    string tenant_id = 3;

    // Dataset name.
    string name = 4;

    // Dataset language (e.g. <code>"English"</code>).
    string language = 5;

    // Dataset description.
    string description = 6;

    // Embedding model name.
    string embedding_model = 7;

    // Access permission.
    RagPermission permission = 8;

    // ID of RAGFlow user who created the dataset.
    string created_by = 9;

    // Number of documents in the dataset.
    int32 document_count = 10;

    // Number of tokens in the dataset.
    int32 token_num = 11;

    // Number of chunks of all documents in the dataset.
    int32 chunk_count = 12;

    // Default similarity threshold (0.0-1.0).
    float similarity_threshold = 13;

    // Default vector similarity weight (0.0-1.0).
    float vector_similarity_weight = 14;

    // Default chunking method for documents in this dataset.
    RagChunkMethod chunk_method = 15;

    // Optional. Pipeline ID.
    string pipeline_id = 16;

    // Document parser configuration (auto-generated based on chunk_method).
    RagParserConfig parser_config = 17;

    // Pagerank.
    int32 pagerank = 18;

    // Optional. GraphRAG task ID.
    string graphrag_task_id = 19;

    // Optional. Finish time of GraphRAG task (ISO 8601 datetime).
    string graphrag_task_finish_at = 20;

    // Optional. RAPTOR task ID.
    string raptor_task_id = 21;

    // Optional. Finish time of RAPTOR task (ISO 8601 datetime).
    string raptor_task_finish_at = 22;

    // Optional. Mindmap task ID.
    string mindmap_task_id = 23;

    // Optional. Finish time of Mindmap task (ISO 8601 datetime).
    string mindmap_task_finish_at = 24;

    // Optional. Status of dataset (<code>"0"</code>: inactive, <code>"1"</code>: active).
    string status = 25;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 create_time = 26;

    // Creation date (ISO 8601 datetime).
    string create_date = 27;

    // Last update timestamp (Unix timestamp in milliseconds).
    int64 update_time = 28;

    // Last update date (ISO 8601 datetime).
    string update_date = 29;
}

// Request message for updating an existing dataset.
// The same field constraints as for <code>RagCreateDatasetRequest</code> apply here.
message RagUpdateDatasetRequest {

    // Required. The agent to update the dataset for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID.
    string dataset_id = 2;

    // Optional. New dataset name.
    string name = 3;

    // Optional. New dataset description.
    string description = 4;

    // Optional. New avatar image.
    string avatar = 5;

    // Optional. New access permission.
    RagPermission permission = 6;

    // Optional. New chunk method.
    RagChunkMethod chunk_method = 7;

    // Optional. New parser config (deep merged with existing).
    RagParserConfig parser_config = 8;

    // Optional. New embedding model (cannot change if chunk_count > 0).
    string embedding_model = 9;

    // Optional. PageRank value.
    int32 pagerank = 10;
}

// Request message for deleting one or more of a RAGFlow resource.
message RagDeleteRequest {

    // Required. The agent to delete datasets from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Optional. IDs of resources to delete. If empty and <code>delete_all</code> is <code>true</code>, deletes all. Duplicate IDs are not allowed.
    repeated string ids = 2;

    // Optional. Delete all (needed because protobuf cannot represent <code>ids=null</code>).
    optional bool delete_all = 3;
}

// Request message for listing datasets with pagination and filtering.
message RagListDatasetsRequest {

    // Required. The agent to list all datasets from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Optional. Pagination parameters.
    RagPagination pagination = 2;

    // Optional. Filter by dataset ID.
    string id = 3;

    // Optional. Filter by dataset name.
    string name = 4;

    // Optional. Sort field (default: <code>create_time</code>).
    string orderby = 5;

    // Optional. Sort descending (default: <code>true</code>).
    optional bool desc = 6;
}

// Response message for listing datasets.
message RagDatasetList {

    // List of datasets.
    repeated RagDataset datasets = 1;
}

// Request message with a single dataset ID.
message RagDatasetIdRequest {

    // Required. The agent to list all datasets from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID.
    string dataset_id = 2;
}

// Response message for getting a dataset's knowledge graph.
message RagGetKnowledgeGraphResponse {

    // Graph structure with nodes (max 256) and edges (max 128).<br>
    // Format: <code>{nodes: [{id, pagerank}], edges: [{source, target, weight}]}</code>
    google.protobuf.Struct graph = 1;

    // Mind map structure (optional).
    google.protobuf.Struct mind_map = 2;

    // Additional fields to pass through to RAGFlow.
    google.protobuf.Struct additional_fields = 3;
}

// Response message for starting construction of a knowledge graph.
message RagConstructKnowledgeGraphResponse {

    // ID of the GraphRAG task.
    string graphrag_task_id = 1;
}

// Status of a task.
message RagTaskStatus {

    // Task ID.
    string id = 1;

    // Document ID.
    string doc_id = 2;

    // Start page.
    int32 from_page = 3;

    // End page.
    int32 to_page = 4;

    // Task type.
    string task_type = 5;

    // Priority.
    int32 priority = 6;

    // Optional. Start time of the task (ISO 8601 datetime).
    string begin_at = 7;

    // Current duration of the task (in seconds).
    float process_duration = 8;

    // Task progress (0.0 - 1.0).
    float progress = 9;

    // Task progress message.
    string progress_msg = 10;

    // Retry count.
    int32 retry_count = 11;

    // Digest.
    string digest = 12;

    // List of document chunk IDs as a string.
    string chunk_ids = 13;
}


// Response message for starting RAPTOR construction.
message RagConstructRaptorResponse {

    // ID of the GraphRAG task.
    string raptor_task_id = 1;
}

// ============================================================================
// Document Management Types
// ============================================================================

// Request message for uploading documents to a dataset.<br>
// Documents are uploaded via streaming multipart form data.
message RagUploadDocumentsRequest {

    // Required. The agent to upload documents for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Metadata for the upload (first message only).
    message RagMetadata {

        // Required. Target dataset ID to upload documents to.
        string dataset_id = 1;

        // Required. Metadata for all files being uploaded in this stream.
        repeated RagFileMetadata files = 2;
    }

    // First message must contain metadata, subsequent messages contain chunks.
    oneof payload {

        // First message: declares all files to be uploaded.
        RagMetadata metadata = 2;

        // Subsequent messages: stream file data chunks.
        RagUploadChunk chunk = 3;
    }
}

// Response message containing a list of documents.
message RagDocumentList {

    // List of documents.
    repeated RagDocument documents = 1;
}

// Document uploaded to a dataset.
message RagDocument {

    // Document UUID.
    string id = 1;

    // Base64-encoded thumbnail image in the format <code>"data:image/[png|jpeg];base64,&lt;base64_string&gt;"</code>. Maximum 65,535 characters.
    string thumbnail = 2;

    // Parent dataset ID.
    string dataset_id = 3;

    // Chunking method used for this document.
    RagChunkMethod chunk_method = 4;

    // Pipeline ID.
    string pipeline_id = 5;

    // Parser configuration used for chunking this document.
    RagParserConfig parser_config = 6;

    // Source type indicating how the document was added (e.g., <code>"local"</code> for direct uploads, <code>"knowledgebase"</code> for file system imports).
    string source_type = 7;

    // File type or extension (e.g., <code>"pdf"</code>, <code>"docx"</code>, <code>"txt"</code>).
    string type = 8;

    // ID of the user who created the document.
    string created_by = 9;

    // Document filename.
    string name = 10;

    // Storage location path in the backend file system or object storage.
    string location = 11;

    // File size in bytes.
    int64 size = 12;

    // Number of chunks extracted from this document (initially <code>0</code> until parsed).
    int32 chunk_count = 13;

    // Number of tokens across all chunks in this document.
    int32 token_count = 14;

    // Processing progress as a decimal value between <code>0.0</code> (not started) and <code>1.0</code> (complete).
    float progress = 15;

    // Human-readable progress message describing current processing state.
    string progress_msg = 16;

    // Processing start timestamp (ISO 8601 datetime string).
    string process_begin_at = 17;

    // Total processing duration in seconds.
    float process_duration = 18;

    // Custom metadata fields specific to this document (arbitrary key-value pairs).
    google.protobuf.Struct meta_fields = 19;

    // Actual file extension extracted from the file (may differ from filename extension).
    string suffix = 20;

    // Document processing status.
    RagDocumentStatus run = 21;

    // Validation status indicating if document is enabled (<code>"1"</code>=valid/enabled, <code>"0"</code>=invalid/disabled).
    string status = 22;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 create_time = 23;

    // Creation date (ISO 8601 datetime string).
    string create_date = 24;

    // Last update timestamp (Unix timestamp in milliseconds).
    int64 update_time = 25;

    // Last update date (ISO 8601 datetime string).
    string update_date = 26;
}

// Document processing status.
enum RagDocumentStatus {

    // Document has not started processing.
    UNSTART = 0;

    // Document is currently being processed.
    RUNNING = 1;

    // Document processing was cancelled.
    CANCEL = 2;

    // Document processing completed successfully.
    DONE = 3;

    // Document processing failed.
    FAIL = 4;
}

// Request message for updating an existing document's metadata and configuration.
message RagUpdateDocumentRequest {

    // Required. The agent to update the document for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the document.
    string dataset_id = 2;

    // Required. Document ID to update.
    string document_id = 3;

    // Optional. Maximum length 255. New document name (file extension must remain the same).
    string name = 4;

    // Optional. New chunking method (resets document to <code>UNSTART</code> status and deletes all existing chunks).
    RagChunkMethod chunk_method = 5;

    // Optional. New parser configuration (deep merged with existing configuration).
    RagParserConfig parser_config = 6;

    // Optional. Document enabled/disabled status.
    optional bool enabled = 7;

    // Optional. Custom metadata fields for document-specific metadata (replaces existing metadata).
    google.protobuf.Struct meta_fields = 8;
}

// Request message for downloading the original document file.
message RagDownloadDocumentRequest {

    // Required. The agent to download the document from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the document.
    string dataset_id = 2;

    // Required. Document ID to download.
    string document_id = 3;
}

// Request message for listing documents in a dataset with pagination and filtering.
message RagListDocumentsRequest {

    // Required. The agent to list documents from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID to list documents from.
    string dataset_id = 2;

    // Optional. Filter by specific document ID.
    string id = 3;

    // Optional. Filter by document name (exact match).
    string name = 4;

    // Optional. Pagination parameters.
    RagPagination pagination = 5;

    // Optional. Sort field (default: <code>"create_time"</code>). Accept any field of <code>RagDocument</code>.
    string orderby = 6;

    // Optional. Sort in descending order (default: <code>true</code>).
    optional bool desc = 7;

    // Optional. Search keywords to filter documents (searches in document name and metadata).
    string keywords = 8;

    // Optional. Suffixes to filter by (e.g. <code>["pdf", "png", "docx"]</code>).
    repeated string suffix = 9;

    // Optional. Document status to filter by.
    repeated RagDocumentStatus run_status = 10;

    // Optional. Filter by creation time start (Unix timestamp in milliseconds, <code>0</code> = no filter).
    int64 create_time_from = 11;

    // Optional. Filter by creation time end (Unix timestamp in milliseconds, <code>0</code> = no filter).
    int64 create_time_to = 12;
}

// Response message for listing documents.
message RagListDocumentsResponse {

    // Total number of documents matching the filter criteria (not limited by pagination).
    int32 total = 1;

    // List of documents for the current page.
    repeated RagDocument docs = 2;
}

// Request message for deleting one or more documents from a dataset.
message RagDeleteDocumentsRequest {

    // Required. The agent to delete documents from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the documents to delete.
    string dataset_id = 2;

    // Optional. Document IDs to delete. If empty and <code>delete_all</code> is <code>true</code>, deletes all documents in the dataset.
    repeated string ids = 3;

    // Optional. Delete all documents in the dataset (needed because protobuf cannot represent <code>ids=null</code>).
    optional bool delete_all = 4;
}

// ============================================================================
// Chunk Management Types
// ============================================================================

// Request message for starting document parsing.<br>
// Parsing extracts chunks from documents using the configured chunk method.
message RagParseDocumentsRequest {

    // Required. The agent to parse documents for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the documents to parse.
    string dataset_id = 2;

    // Required. Document IDs to parse into chunks (queues documents for background processing).
    repeated string document_ids = 3;
}

// Request message for stopping document parsing.<br>
// Only documents currently being processed can be stopped.
message RagStopParsingRequest {

    // Required. The agent to stop parsing for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the documents to stop parsing.
    string dataset_id = 2;

    // Required. Document IDs to stop parsing (only stops documents with progress between <code>0</code> and <code>1</code>).
    repeated string document_ids = 3;
}

// Request message for listing chunks of a document with pagination.
message RagListChunksRequest {

    // Required. The agent to list chunks from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the document.
    string dataset_id = 2;

    // Required. Document ID to list chunks from.
    string document_id = 3;

    // Optional. Pagination parameters.
    RagPagination pagination = 4;

    // Optional. Search keywords to filter chunks (supports content highlighting in results).
    string keywords = 5;

    // Optional. Filter by specific chunk ID.
    string id = 6;
}

// Response message for listing chunks.
message RagListChunksResponse {

    // Total number of chunks matching the filter criteria (before pagination).
    int32 total = 1;

    // List of chunks for the current page.
    repeated RagChunk chunks = 2;

    // Document details for the parent document.
    RagDocument doc = 3;
}

// Chunk of text extracted from a document.<br>
// Chunks are the basic retrieval units used for vector similarity search in RAG.
message RagChunk {

    // Chunk ID (computed as xxhash of content combined with document_id).
    string id = 1;

    // Parent dataset ID.
    string dataset_id = 2;

    // Parent document ID.
    string document_id = 3;

    // Chunk text content (the actual text segment extracted from the document).
    string content = 4;

    // Document name keyword used for filtering and identification.
    string docnm_kwd = 5;

    // Important keywords extracted from or manually assigned to this chunk.
    repeated string important_keywords = 6;

    // Associated questions for Q&amp;A chunks (used when <code>chunk_method=qa</code>).
    repeated string questions = 7;

    // Associated image ID if this chunk references an image.
    string image_id = 8;

    // Availability status indicating if the chunk is active and can be retrieved (can be disabled without deletion).
    optional bool available = 9;

    // Position information in the original document.<br>
    // Each position is an array of 5 integers representing location data (format varies by document type).
    repeated google.protobuf.ListValue positions = 10;

    // Creation timestamp (ISO 8601 datetime string).
    string create_time = 11;

    // Creation timestamp as a floating-point Unix timestamp.
    float create_timestamp = 12;

    // Document name used as a keyword for retrieval.
    string document_keyword = 13;

    // Similarity score between <code>0.0</code> and <code>1.0</code> (only populated in retrieval responses).
    float similarity = 14;

    // Embedding vector for this chunk (optional, rarely included in responses for performance reasons).
    google.protobuf.Struct vector = 15;

    // Additional fields returned by RAGFlow not explicitly defined above.
    google.protobuf.Struct additional_fields = 16;
}

// Request message for manually adding a chunk to a document.<br>
// The chunk content is automatically tokenized and embeddings are generated.
message RagAddChunkRequest {

    // Required. The agent to add the chunk for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the document.
    string dataset_id = 2;

    // Required. Document ID to add the chunk to.
    string document_id = 3;

    // Required. Chunk text content.
    string content = 4;

    // Optional. Important keywords to associate with this chunk.
    repeated string important_keywords = 5;

    // Optional. Associated questions for this chunk (useful for Q&amp;A-style retrieval).
    repeated string questions = 6;
}

// Response message for adding a chunk.
message RagAddChunkResponse {

    // The newly created chunk.
    RagChunk chunk = 1;
}

// Request message for removing one or more chunks from a document.
message RagRemoveChunksRequest {

    // Required. The agent to remove chunks from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the document.
    string dataset_id = 2;

    // Required. Document ID to remove chunks from.
    string document_id = 3;

    // Required. Chunk IDs to remove. If empty, removes all chunks from the document.
    repeated string chunk_ids = 4;
}

// Request message for updating an existing chunk's content and metadata.<br>
// Content changes trigger re-tokenization and re-generation of embeddings.
message RagUpdateChunkRequest {

    // Required. The agent to update the chunk for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset ID containing the document.
    string dataset_id = 2;

    // Required. Document ID containing the chunk.
    string document_id = 3;

    // Required. Chunk ID to update.
    string chunk_id = 4;

    // Optional. New chunk content (re-tokenizes and re-generates embeddings if changed).
    string content = 5;

    // Optional. Updated important keywords for this chunk.
    repeated string important_keywords = 6;

    // Optional. Updated questions associated with this chunk.
    repeated string questions = 7;

    // Optional. Availability status (disable chunk without deleting it).
    optional bool available = 8;

    // Position information in the original document.<br>
    // Each position is an array of 5 integers representing location data (format varies by document type).
    repeated google.protobuf.ListValue positions = 9;
}

// Request message for retrieving chunks using vector similarity search.<br>
// Supports hybrid search combining vector similarity with keyword matching.
message RagRetrievalRequest {

    // Required. The agent to retrieve chunks for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Dataset IDs to search (all datasets must use the same embedding model).
    repeated string dataset_ids = 2;

    // Optional. Pagination parameters.
    RagPagination pagination = 3;

    // Required. Query string to search for.
    string question = 4;

    // Optional. Filter by specific document IDs within the datasets.
    repeated string document_ids = 5;

    // Optional. Include knowledge graph retrieval to enhance results with graph relationships.
    optional bool use_kg = 6;

    // Optional. Cross-language translation codes to enable multilingual retrieval.
    repeated string cross_languages = 7;

    // Optional. Metadata filter condition to restrict results based on document metadata.
    RagMetadataConditions metadata_condition = 8;

    // Optional. Minimum similarity score threshold between <code>0.0</code> and <code>1.0</code> (default: <code>0.2</code>).
    float similarity_threshold = 9;

    // Optional. Weight for vector similarity versus keyword matching between <code>0.0</code> and <code>1.0</code> (default: <code>0.3</code>).<br>
    // Higher values favor vector similarity, lower values favor keyword matching.
    float vector_similarity_weight = 10;

    // Optional. Maximum number of chunks to retrieve before reranking (default: <code>1024</code>).
    int32 top_k = 11;

    // Optional. Rerank model ID to reorder results after initial retrieval.
    string rerank_id = 12;

    // Optional. Whether to highlight matched content in the returned chunks.
    optional bool highlight = 13;

    // Optional. Extract additional keywords from the query to improve retrieval.
    optional bool keyword = 14;
}

// List of document metadata conditions.
message RagMetadataConditions {

    // Optional. List of conditions.
    repeated RagMetadataCondition conditions = 1;
}

// Condition to filter document metadata on.
message RagMetadataCondition {

    // Required. Metadata field name.
    string name = 1;

    // Required. Comparison operator. Can be one of: <code>"contains"</code>, <code>"not contains"</code>, <code>"start with"</code>, <code>"empty"</code>, <code>"not empty"</code>, <code>"="</code>, <code>""</code>, <code>"&lt;"</code>, <code>"&gt;</code>, <code>""</code>, <code>""</code>
    string comparison_operator = 2;

    // Required. Value to compare to.
    string value = 3;
}

// Response message for chunk retrieval.
message RagRetrievalResponse {

    // Retrieved chunks with similarity scores populated (ordered by relevance).
    repeated RagChunk chunks = 1;

    // Document aggregations providing statistics about which documents matched.
    repeated google.protobuf.Struct doc_aggs = 2;

    // Total number of chunks matching the query (before pagination).
    int32 total = 3;

    // Additional fields returned by RAGFlow not explicitly defined above.
    google.protobuf.Struct additional_fields = 4;
}

// ============================================================================
// File Management Types
// ============================================================================

// Request message for uploading files via streaming multipart form data.
// RAGFlow supports individual and bulk file uploads. Files can be uploaded to a specific folder or to the root directory if no parent folder is specified.
message RagUploadFilesRequest {

    // Required. The agent to upload files for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Metadata for the upload operation (must be sent in first message only).
    message RagMetadata {

        // Optional. Parent folder ID. If not provided, files will be uploaded to root directory.
        string parent_id = 1;

        // Required. Metadata for all files being uploaded in this request.
        repeated RagFileMetadata files = 2;
    }

    // First message must contain metadata; subsequent messages contain file data chunks.
    oneof payload {

        // First message: declares all files to be uploaded.
        RagMetadata metadata = 2;

        // Subsequent messages: stream file data in chunks.
        RagUploadChunk chunk = 3;
    }
}

// Response message containing a list of files.
message RagFileList {

    // Uploaded files. RAGFlow automatically creates intermediate folders as needed during upload.
    repeated RagFile files = 1;
}

// File or folder in RAGFlow file system.
message RagFile {

    // File or folder UUID.
    string id = 1;

    // Parent folder ID. Empty string for root-level items.
    string parent_id = 2;

    // Tenant ID.
    string tenant_id = 3;

    // ID of the user who created the file.
    string created_by = 4;

    // File or folder name.
    string name = 5;

    // Storage location path within the RAGFlow file system.
    string location = 6;

    // File size in bytes (0 for folders).
    int64 size = 7;

    // File type/extension or <code>"folder"</code> for directories. Check <code>type == "folder"</code> to distinguish folders from files.
    string type = 8;

    // Source type indicating file origin (e.g., <code>"local"</code> for uploaded files).
    string source_type = 9;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 create_time = 10;

    // Creation date (ISO 8601 datetime format).
    string create_date = 11;

    // Last update timestamp (Unix timestamp in milliseconds).
    int64 update_time = 12;

    // Last update date (ISO 8601 datetime format).
    string update_date = 13;
}

// Request message for creating a file or folder in RAGFlow.
message RagCreateFileRequest {

    // Required. The agent to create the file for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Maximum length 255. Name of the file or folder to create.
    string name = 2;

    // Optional. Parent folder ID. If not provided, creates in root directory.
    string parent_id = 3;

    // Required. Type of item to create: <code>"folder"</code> for directories or <code>"virtual"</code> for virtual files.
    RagCreateFileFileType type = 4;
}

// Available file types for file creation.
enum RagCreateFileFileType {

    // virtual file
    virtual = 0;

    // folder
    folder = 1;
}

// Request message for listing files and folders.
message RagListFilesRequest {

    // Required. The agent to list files from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Optional. Folder ID to list contents from. If not provided, lists root directory contents.
    string parent_id = 2;

    // Optional. Pagination parameters. Default page size is 15 items per page.
    RagPagination pagination = 3;

    // Optional. Search keywords to filter files by name or other searchable attributes.
    string keywords = 4;

    // Optional. Field to sort results by. All fields of <code>RagFile</code> are possible.
    string orderby = 5;

    // Optional. Sort in descending order. Default is <code>true</code> (newest first).
    optional bool desc = 6;
}

// Response message for listing files and folders.
message RagListFilesResponse {

    // Total number of files and folders matching the query (before pagination).
    int32 total = 1;

    // List of files and folders in the current page.
    repeated RagFile files = 2;

    // Information about the parent folder being listed.
    RagFile parent_folder = 3;
}

// Empty request message with only the parent field.
message RagGetRootFolderRequest {

    // Required. The agent to get the parent folder for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;
}

// Response message for getting the root folder.
message RagGetRootFolderResponse {

    // The root folder of the file system.
    RagFile root_folder = 1;
}

// Request message for requests that only need a file ID.
message RagFileIdRequest {

    // Required. The agent to rename the file for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. File ID.
    string file_id = 2;
}

// Response message for getting the parent folder of a file.
message RagGetParentFolderResponse {

    // The immediate parent folder of the requested file.
    RagFile parent_folder = 1;
}

// Response message for getting all parent folders in the hierarchy.
message RagParentFoldersList {

    // All parent folders in the hierarchy, from immediate parent to root folder.
    repeated RagFile parent_folders = 1;
}

// Request message for deleting files or folders.
message RagDeleteFilesRequest {

    // Required. The agent to delete files from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. UUIDs of files or folders to delete. Supports batch deletion.
    repeated string file_ids = 2;
}

// Request message for renaming a file or folder.
message RagRenameFileRequest {

    // Required. The agent to rename the file for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. UUID of the file or folder to rename.
    string file_id = 2;

    // Required. New name for the file or folder. For files, the extension must remain the same.
    string name = 3;
}

// Request message for moving files or folders.
message RagMoveFileRequest {

    // Required. The agent to move files for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. UUIDs of source files or folders to move. Supports batch move operations.
    repeated string src_file_ids = 2;

    // Required. UUID of the destination folder.
    string dest_file_id = 3;
}

// Request message for converting files to documents and linking them to datasets.
// RAGFlow allows linking uploaded files to multiple target datasets for RAG operations.
message RagFileToDocumentRequest {

    // Required. The agent to convert files to documents for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. UUIDs of files to convert. If folders are provided, processes contents recursively.
    repeated string file_ids = 2;

    // Required. Target dataset IDs (knowledge base IDs). A single file can be linked to multiple datasets.
    repeated string kb_ids = 3;
}

// Response message containing a list of file-to-document associations.
message RagFileToDocumentList {

    // List of file-to-document associations created during the conversion operation.
    repeated RagFileToDocument files_to_documents = 1;
}

// Association between a file and a document in a dataset.
// Tracks the relationship when files are converted to documents for use in RAG operations.
message RagFileToDocument {

    // UUID of the file-to-document association.
    string id = 1;

    // UUID of the source file.
    string file_id = 2;

    // UUID of the generated document in the dataset.
    string document_id = 3;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 create_time = 4;

    // Creation date (ISO 8601 datetime format).
    string create_date = 5;

    // Last update timestamp (Unix timestamp in milliseconds).
    int64 update_time = 6;

    // Last update date (ISO 8601 datetime format).
    string update_date = 7;
}

// ============================================================================
// Chat Management Types
// ============================================================================

// Request message for creating a new chat assistant.
message RagCreateChatAssistantRequest {

    // Required. The agent to create a chat assistant for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Maximum length 255. Unique name for the chat assistant.
    string name = 2;

    // Optional. Description of the chat assistant's purpose.
    string description = 3;

    // Optional. Base64-encoded icon in the format <code>"data:image/[png|jpeg];base64,&lt;base64_string&gt;"</code>.
    string avatar = 4;

    // Optional. Dataset IDs to use as knowledge base (all datasets must have parsed files and use the same embedding model).
    repeated string dataset_ids = 5;

    // Optional. LLM configuration settings.
    RagLlmSetting llm = 6;

    // Optional. Prompt and retrieval configuration settings.
    RagPromptConfig prompt = 7;

    // Optional. Additional fields to pass through to RAGFlow.
    google.protobuf.Struct additional_fields = 8;
}

// LLM configuration for chat assistant.
message RagLlmSetting {

    // Optional. LLM model name. If not set, the user's default model will be used.
    string model_name = 1;

    // Optional. Minimum 0.0. Maximum 2.0. Default 0.1. Sampling temperature. Controls randomness in responses.
    float temperature = 2;

    // Optional. Minimum 0.0. Maximum 1.0. Default 0.3. Nucleus sampling parameter. Filters token choices by cumulative probability.
    float top_p = 3;

    // Optional. Minimum -2.0. Maximum 2.0. Default 0.4. Frequency penalty. Reduces repetition of frequent tokens.
    float frequency_penalty = 4;

    // Optional. Minimum -2.0. Maximum 2.0. Default 0.7. Presence penalty. Reduces repetition of any tokens already used.
    float presence_penalty = 5;

    // Optional. Maximum number of tokens to generate.
    int32 max_tokens = 6;

    // Optional. Additional fields to pass through to RAGFlow.
    google.protobuf.Struct additional_fields = 7;
}

// Prompt and retrieval configuration for chat assistant.
message RagPromptConfig {

    // Optional. System prompt (RAGFlow provides default if not specified).
    string prompt = 1;

    // Optional. Prompt template variables for dynamic content insertion.
    repeated RagPromptVariable variables = 2;

    // Optional. Opening message displayed at conversation start.
    string opener = 3;

    // Optional. Default <code>true</code>. Show quotations from retrieved source chunks in responses.
    optional bool show_quote = 4;

    // Optional. Response to return when no relevant chunks are found in the knowledge base.
    string empty_response = 5;

    // Optional. Default <code>false</code>. Enable text-to-speech for responses.
    optional bool tts = 6;

    // Optional. Default <code>true</code>. Refine and optimize multi-turn conversation context.
    optional bool refine_multiturn = 7;

    // Optional. Minimum 0.0. Maximum 1.0. Default 0.2. Minimum similarity score for chunk retrieval.
    float similarity_threshold = 8;

    // Optional. Minimum 0.0. Maximum 1.0. Default 0.7. Weight for keywords versus vector similarity in hybrid search.
    float keywords_similarity_weight = 9;

    // Optional. Default 6. Number of chunks to retrieve after reranking.
    int32 top_n = 10;

    // Optional. Default 1024. Maximum chunks to retrieve before reranking.
    int32 top_k = 11;

    // Optional. Rerank model ID for reordering retrieved chunks. If not specified, cosine similarity is used.
    string rerank_model = 12;

    // Optional. Additional fields to pass through to RAGFlow.
    google.protobuf.Struct additional_fields = 13;
}

// Prompt template variable for dynamic content insertion.
message RagPromptVariable {

    // Variable name used in prompt template.
    string key = 1;

    // Whether this variable is optional in the template.
    optional bool optional = 2;
}

// Chat assistant configuration.
message RagChatAssistant {

    // Chat UUID.
    string id = 1;

    // Tenant ID.
    string tenant_id = 2;

    // Chat name (required, unique).
    string name = 3;

    // Optional description.
    string description = 4;

    // Base64-encoded avatar image.
    string avatar = 5;

    // Language of the chat.
    string language = 6;

    // Dataset IDs.
    repeated string dataset_ids = 7;

    // Full dataset objects.
    repeated RagDataset datasets = 8;

    // LLM configuration.
    RagLlmSetting llm = 9;

    // Prompt type.
    RagPromptType prompt_type = 10;

    // Prompt and retrieval configuration.
    RagPromptConfig prompt = 11;

    // Metadata filter.
    google.protobuf.Struct meta_data_filter = 12;

    // Whether to insert reference index into answer. <code>"1"</code> yes, <code>"0"</code> no.
    string do_refer = 13;

    // Validation status indicating if chat is enabled (<code>"1"</code>=valid/enabled, <code>"0"</code>=invalid/disabled).
    string status = 14;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 create_time = 15;

    // Creation date (ISO 8601 datetime).
    string create_date = 16;

    // Last update timestamp (Unix timestamp in milliseconds).
    int64 update_time = 17;

    // Last update date (ISO 8601 datetime).
    string update_date = 18;
}

// Chat assistant prompt type.
enum RagPromptType {

    // simple
    simple = 0;

    // advanced
    advanced = 1;
}

// Request message for updating an existing chat assistant.
message RagUpdateChatAssistantRequest {

    // Required. The agent containing the chat assistant to update.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. UUID of the chat assistant to update.
    string chat_id = 2;

    // Required. Maximum length 255. Unique name for the chat assistant.
    string name = 3;

    // Optional. Description of the chat assistant's purpose.
    string description = 4;

    // Optional. Base64-encoded icon in the format <code>"data:image/[png|jpeg];base64,&lt;base64_string&gt;"</code>.
    string avatar = 5;

    // Optional. Dataset IDs to use as knowledge base (all datasets must have parsed files and use the same embedding model).
    repeated string dataset_ids = 6;

    // Optional. LLM configuration settings.
    RagLlmSetting llm = 7;

    // Optional. Prompt and retrieval configuration settings.
    RagPromptConfig prompt = 8;

    // Optional. Additional fields to pass through to RAGFlow.
    google.protobuf.Struct additional_fields = 9;
}

// Request message for listing chat assistants.
message RagListChatAssistantsRequest {

    // Required. The agent to list chat assistants from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Optional. Pagination parameters for paging through results.
    RagPagination pagination = 2;

    // Optional. Filter by chat assistant UUID.
    string id = 3;

    // Optional. Filter by chat assistant name.
    string name = 4;

    // Sort field (default: <code>"create_time"</code>).
    string orderby = 5;

    // Optional. Sort in descending order (default: <code>true</code>).
    optional bool desc = 6;

    // Optional. Additional fields to pass through to RAGFlow.
    google.protobuf.Struct additional_fields = 7;
}

// Response message for listing chat assistants.
message RagChatAssistantList {

    // List of chat assistants (with full dataset objects embedded).
    repeated RagChatAssistant chats = 1;
}

// ============================================================================
// Agent Management Types
// ============================================================================

// Request message for creating a new RAGFlow agent.
message RagCreateAgentRequest {

    // Required. The agent to create the RAGFlow agent for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Optional. Base64-encoded icon in the format <code>"data:image/[png|jpeg];base64,&lt;base64_string&gt;"</code>.
    string avatar = 2;

    // Required. Maximum length 255. Unique agent title. Must be unique within the project.
    string title = 3;

    // Optional. Default <code>me</code>
    RagPermission permission = 4;

    // Optional. Agent description providing details about the agent's purpose and functionality.
    string description = 5;

    // Optional. Max length 32. Canvas type.
    string canvas_type = 6;

    // Optional. Canvas category.
    RagCanvasCategory canvas_category = 7;

    // Required. Canvas DSL configuration defining the agent's workflow.
    google.protobuf.Struct dsl = 8;
}

// Agent canvas category.
enum RagCanvasCategory {

    // agent canvas
    agent_canvas = 0;

    // dataflow canvas
    dataflow_canvas = 1;
}

// Request message for updating an existing RAGFlow agent.
message RagUpdateAgentRequest {

    // Required. The agent to update the RAGFlow agent for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. ID of the RAGFlow agent to update.
    string agent_id = 2;

    // Optional. Base64-encoded icon in the format <code>"data:image/[png|jpeg];base64,&lt;base64_string&gt;"</code>.
    string avatar = 3;

    // Optional. Maximum length 255. Unique agent title. Must be unique within the project.
    string title = 4;

    // Optional. Default <code>me</code>
    RagPermission permission = 5;

    // Optional. Agent description providing details about the agent's purpose and functionality.
    string description = 6;

    // Optional. Max length 32. Canvas type.
    string canvas_type = 7;

    // Optional. Canvas category.
    RagCanvasCategory canvas_category = 8;

    // Optional. Canvas DSL configuration defining the agent's workflow.
    google.protobuf.Struct dsl = 9;
}

// Request message for deleting a RAGFlow agent.
message RagDeleteAgentRequest {

    // Required. The agent to delete the RAGFlow agent from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. ID of the RAGFlow agent to delete.
    string agent_id = 2;
}

// Request message for listing RAGFlow agents.
message RagListAgentsRequest {

    // Required. The agent to list RAGFlow agents from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Optional. Pagination parameters to control the number and offset of results.
    RagPagination pagination = 2;

    // Optional. Filter results by agent title. Only agents with matching titles will be returned.
    string title = 3;

    // Optional. Sort field for ordering results. Default: <code>"update_time"</code>.
    string orderby = 4;

    // Optional. Sort in descending order. If <code>true</code>, results are sorted from highest to lowest.
    // Default: <code>true</code>.
    optional bool desc = 5;

    // Optional. Filter results by specific agent ID.
    string id = 6;
}

// Response message containing a list of RAGFlow agents.
message RagAgentList {

    // List of RAGFlow agents.
    repeated RagAgent agents = 1;
}

// RAGFlow agent (workflow-based AI assistant).
// Agents are workflow-based AI assistants configured using Canvas DSL.
message RagAgent {

    // Agent UUID uniquely identifying this agent.
    string id = 1;

    // Optional. Base64-encoded icon in the format <code>"data:image/[png|jpeg];base64,&lt;base64_string&gt;"</code>.
    string avatar = 2;

    // User ID of the agent owner.
    string user_id = 3;

    // Unique agent title.
    string title = 4;

    // Agent access permissions
    RagPermission permission = 5;

    // Agent description providing details about the agent's purpose and functionality.
    string description = 6;

    // Canvas type.
    string canvas_type = 7;

    // Canvas category.
    RagCanvasCategory canvas_category = 8;

    // Canvas DSL configuration defining the agent's workflow.
    google.protobuf.Struct dsl = 9;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 create_time = 10;

    // Creation date in ISO 8601 datetime format.
    string create_date = 11;

    // Last update timestamp (Unix timestamp in milliseconds).
    int64 update_time = 12;

    // Last update date in ISO 8601 datetime format.
    string update_date = 13;
}

// ============================================================================
// Session Management Types
// ============================================================================

// Request message for creating a new chat session.
message RagCreateChatSessionRequest {

    // Required. The agent to create a chat session for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Parent chat assistant UUID.
    string chat_id = 2;

    // Optional. Maximum length 255. Session name (default: <code>"New session"</code>).
    string name = 3;

    // Optional. Maximum length 255. User identifier for tracking conversation ownership.
    string user_id = 4;
}

// Chat session containing conversation history for a chat assistant.
message RagChatSession {

    // Session UUID.
    string id = 1;

    // Parent chat assistant UUID.
    string chat_id = 2;

    // Session name (default: <code>"New session"</code>).
    string name = 3;

    // Message history in chronological order.
    repeated RagMessage messages = 4;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 create_time = 6;

    // Creation date (ISO 8601 datetime).
    string create_date = 7;

    // Last update timestamp (Unix timestamp in milliseconds).
    int64 update_time = 8;

    // Last update date (ISO 8601 datetime).
    string update_date = 9;
}

// Message in a conversation session.
message RagMessage {

    // Role of the message sender.
    RagMessageRole role = 1;

    // Message content text.
    string content = 2;

    // Additional fields returned by RAGFlow.
    google.protobuf.Struct additional_fields = 4;
}

// Role of message sender in conversation.
enum RagMessageRole {

    // Message from user.
    user = 0;

    // Message from AI assistant.
    assistant = 1;

    // System message.
    system = 2;
}

// Request message for updating an existing chat session.
message RagUpdateChatSessionRequest {

    // Required. The agent containing the chat session to update.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Chat assistant UUID.
    string chat_id = 2;

    // Required. Session UUID to update.
    string session_id = 3;

    // Optional. Maximum length 255. New session name.
    string name = 4;

    // Optional. Maximum length 255.  User identifier.
    string user_id = 5;
}

// Request message for listing chat sessions.
message RagListChatSessionsRequest {

    // Required. The agent to list chat sessions from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Chat assistant UUID.
    string chat_id = 2;

    // Optional. Pagination parameters for paging through results.
    RagPagination pagination = 3;

    // Sort field (default: <code>"create_time"</code>).
    string orderby = 4;

    // Optional. Sort in descending order (default: <code>true</code>).
    optional bool desc = 5;

    // Optional. Filter by session name.
    string name = 6;

    // Optional. Filter by session UUID.
    string id = 7;

    // Optional. Filter by user identifier.
    string user_id = 8;
}

// Response message for listing chat sessions.
message RagChatSessionList {

    // List of chat sessions.
    repeated RagChatSession chat_sessions = 1;
}

// Request message for deleting chat sessions.
message RagDeleteChatSessionsRequest {

    // Required. The agent to delete chat sessions from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Chat assistant UUID.
    string chat_id = 2;

    // Optional. Session UUIDs to delete. Specify either this field or <code>delete_all</code>.
    repeated string ids = 3;

    // Optional. Delete all sessions for this chat (needed because protobuf cannot represent <code>ids=null</code>).
    optional bool delete_all = 4;
}

// Request message for listing agent sessions.
message RagListAgentSessionsRequest {

    // Required. The agent to list agent sessions from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. RAGFlow agent UUID.
    string agent_id = 2;

    // Optional. Pagination parameters for paging through results.
    RagPagination pagination = 3;

    // Sort field (default: <code>"update_time"</code>).
    string orderby = 4;

    // Optional. Sort in descending order (default: <code>true</code>).
    optional bool desc = 5;

    // Optional. Filter by session UUID.
    string id = 6;

    // Optional. Filter by user identifier.
    string user_id = 7;

    // Optional. Include DSL workflow configuration in response.
    optional bool dsl = 8;
}

// Response message for listing agent sessions.
message RagAgentSessionList {

    // List of agent sessions.
    repeated RagAgentSession agent_sessions = 1;
}

// Agent session containing conversation history for an agent workflow.
message RagAgentSession {

    // Session UUID.
    string id = 1;

    // RAGFlow agent UUID.
    string agent_id = 2;

    // User identifier.
    string user_id = 3;

    // Message history in chronological order.
    repeated RagMessage messages = 4;

    // Number of tokens used.
    int32 tokens = 5;

    // Session source.
    RagSessionSource source = 6;

    // Agent DSL (Domain Specific Language) workflow configuration.
    google.protobuf.Struct dsl = 7;

    // Session duration in seconds.
    float duration = 8;

    // Conversation round.
    int32 round = 9;

    // Number of likes.
    int32 thumb_up = 10;

    // Optional. Error messages.
    string errors = 11;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 create_time = 12;

    // Creation date (ISO 8601 datetime).
    string create_date = 13;

    // Last update timestamp (Unix timestamp in milliseconds).
    int64 update_time = 14;

    // Last update date (ISO 8601 datetime).
    string update_date = 15;
}

// Session source
enum RagSessionSource {

    // none
    none = 0;

    // agent
    agent = 1;

    // dialog
    dialog = 2;
}

// Request message for deleting agent sessions.
message RagDeleteAgentSessionsRequest {

    // Required. The agent to delete agent sessions from.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. RAGFlow agent UUID.
    string agent_id = 2;

    // Optional. Session UUIDs to delete. Specify either this field or <code>delete_all</code>.
    repeated string ids = 3;

    // Optional. Delete all sessions for this agent (needed because protobuf cannot represent <code>ids=null</code>).
    optional bool delete_all = 4;
}

// ============================================================================
// Completion Types (Streaming)
// ============================================================================

// Request message for generating a chat completion.
message RagChatCompletionRequest {

    // Required. The agent to generate the chat completion for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Chat assistant ID to use for generating the completion.
    string chat_id = 2;

    // Optional. Session ID to continue an existing conversation. If not provided, a new session will be created.
    string session_id = 3;

    // Optional. Maximum length 255. Name for new session. Ignored if <code>session_id</code> is provided.
    string name = 4;

    // Optional. Maximum length 255. User defined ID for new session. Ignored if <code>session_id</code> is provided.
    string user_id = 5;

    // Optional. User question or message to send to the chat assistant.
    string question = 6;

    // Optional. Enable streaming mode. If <code>true</code>, the response will be streamed as Server-Sent Events (SSE).
    // Default: <code>true</code>.
    optional bool stream = 7;

    // Optional. Additional fields to pass through to RAGFlow API.
    google.protobuf.Struct additional_fields = 8;
}

// Response message for chat completion.
// <ul>
//     <li>For streaming: Each message contains a partial response with incremental content.</li>
//     <li>For non-streaming: Single message containing the complete response.</li>
// </ul>
message RagChatCompletionResponse {

    // Response text. Incremental for streaming mode, complete for non-streaming mode.
    string answer = 1;

    // Source references including document chunks used to generate the response.
    // Contains a <code>chunks</code> array with metadata about retrieved documents.
    google.protobuf.Struct reference = 2;

    // Optional. Base64-encoded audio response when text-to-speech is enabled.
    string audio_binary = 3;

    // Message ID uniquely identifying this response.
    string id = 4;

    // Session ID for the conversation.
    string session_id = 5;

    // Prompt used for generation. Usually empty string.
    string prompt = 6;

    // Creation timestamp (Unix timestamp in seconds).
    double created_at = 7;

    // Additional fields returned by RAGFlow API.
    google.protobuf.Struct additional_fields = 8;
}

// Request message for generating an agent completion.
// Agents are workflow-based AI assistants with Domain Specific Language (DSL) configuration.
message RagAgentCompletionRequest {

    // Required. The agent to generate the completion for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. RAGFlow agent ID to use for generating the completion.
    string agent_id = 2;

    // Optional. Session ID to continue an existing conversation. If not provided, a new session will be created.
    string session_id = 3;

    // Required. User question or message to send to the agent.
    string question = 4;

    // Optional. Enable streaming mode. If <code>true</code>, the response will be streamed as Server-Sent Events (SSE).
    // Default: <code>true</code>.
    optional bool stream = 5;

    // Optional. Files to include in the agent's context for processing.
    repeated RagFile files = 6;

    // Optional. Input form data to pass to the agent workflow. The structure depends on the agent's DSL configuration.
    google.protobuf.Struct inputs = 7;

    // Optional. User identifier for tracking and personalization. Ignored if <code>session_id</code> is given.
    string user_id = 8;

    // Optional. Additional fields to pass through to RAGFlow API.
    google.protobuf.Struct additional_fields = 9;
}

// Response message for agent completion.
// <ul>
//     <li>For streaming: Each message contains a partial response with <code>event</code> indicating the event type (e.g., <code>"message"</code>, <code>"message_end"</code>).</li>
//     <li>For non-streaming: Single message with accumulated content.</li>
// </ul>
message RagAgentCompletionResponse {

    // Event type indicating the kind of event in the stream.
    RagAgentEventType event = 1;

    // Message ID uniquely identifying this response.
    string message_id = 2;

    // Creation timestamp (Unix timestamp in milliseconds).
    int64 created_at = 3;

    // Task ID associated with this agent workflow execution.
    string task_id = 4;

    // Event data payload containing the actual response content.
    RagAgentCompletionData data = 5;

    // Session ID for the conversation.
    string session_id = 6;

    // Additional fields returned by RAGFlow API.
    google.protobuf.Struct additional_fields = 7;
}

// Agent completion event type.
enum RagAgentEventType {

    // Regular message event.
    message = 0;

    // Message completion event.
    message_end = 1;
}

// Data payload in agent completion response.
message RagAgentCompletionData {

    // Response text content. Incremental for streaming mode, complete for non-streaming mode.
    string content = 1;

    // Input data that was passed to the agent workflow.
    google.protobuf.Struct inputs = 2;

    // Output data produced by the agent workflow. Structure depends on the agent's DSL configuration.
    google.protobuf.Struct outputs = 3;

    // Source references including document chunks used to generate the response.
    google.protobuf.Struct reference = 4;

    // Additional fields returned by RAGFlow API.
    google.protobuf.Struct additional_fields = 5;
}

// Request message for asking a question using RAGFlow's basic QA endpoint.
message RagAskRequest {

    // Required. The agent to ask the question for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. User question to be answered.
    string question = 2;

    // Required. List of dataset IDs to search for relevant information.
    // The system will search across all specified datasets.
    repeated string dataset_ids = 3;
}

// Response message containing the answer to a user's question.
message RagAskResponse {

    // Generated answer text based on the retrieved information.
    // When streaming is enabled, this field contains incremental text chunks.
    string answer = 1;

    // Source references and citations for the generated answer.
    // Typically includes chunk information, document titles, and similarity scores.
    google.protobuf.Struct reference = 2;
}

// Request message for generating related questions based on a user's query.
message RagRelatedQuestionsRequest {

    // Required. The agent to generate related questions for.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // Required. Original user question to generate related questions from.
    string question = 2;

    // Optional. Industry context to focus the related questions.
    // Helps tailor suggestions to specific domains (e.g., "healthcare", "finance").
    string industry = 3;
}

// Response message containing a list of suggested related questions.
message RagRelatedQuestionsResponse {

    // List of 5-10 related question suggestions based on the original query.
    repeated string questions = 1;
}
