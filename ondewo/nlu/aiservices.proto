// Copyright 2020-2023 ONDEWO GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package ondewo.nlu;

import "google/api/annotations.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/struct.proto";

import "ondewo/nlu/ccai_project.proto";
import "ondewo/nlu/intent.proto";
import "ondewo/nlu/entity_type.proto";
import "ondewo/nlu/session.proto";

// <p>The Central class defining the ondewo ai services</p>
service AiServices {

    // <p>Processes a natural language query and returns detected entities</p>
    rpc ExtractEntities (ExtractEntitiesRequest) returns (ExtractEntitiesResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/entities:extract"
            body: "*"
        };
    };

    // <p>Generates a list of training phrases</p>
    rpc GenerateUserSays (GenerateUserSaysRequest) returns (GenerateUserSaysResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/generate_user_says"
            body: "*"
        };
    };

    // <p>Generate responses from all intents using synonyms</p>
    rpc GenerateResponses (GenerateResponsesRequest) returns (GenerateResponsesResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/generate_responses"
            body: "*"
        };
    };

    // <p>Generates alternative phrase based on original phrase</p>
    rpc GetAlternativeSentences (GetAlternativeSentencesRequest) returns (GetAlternativeSentencesResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/get_alternative:sentence"
            body: "*"
        };
    }

    // <p>Generates alternative training phrase based on original training phrase</p>
    rpc GetAlternativeTrainingPhrases (GetAlternativeTrainingPhrasesRequest) returns (GetAlternativeTrainingPhrasesResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/get_alternative:training_phrases"
            body: "*"
        };
    }

    // <p>Generates synonyms for a certain word</p>
    rpc GetSynonyms (GetSynonymsRequest) returns (GetSynonymsResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/get_synonyms"
            body: "*"
        };
    }

    // <p>Preprocess text and detects intents in a sentence</p>
    rpc ClassifyIntents (ClassifyIntentsRequest) returns (ClassifyIntentsResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/classify_intent"
            body: "*"
        };
    }

    // <p>Processes a natural language query and returns detected entities</p>
    rpc ExtractEntitiesFuzzy (ExtractEntitiesFuzzyRequest) returns (ExtractEntitiesResponse);

    // <p>Generates a single response from a Large Language Model (LLM).
    // This RPC method allows a client to make a request to the LLM and receive
    // a single complete response based on the input parameters provided.</p>
    rpc LlmGenerate (LlmGenerateRequest) returns (LlmGenerateResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/llm_generate"
            body: "*"
        };
    }

    // <p>Generates a response from the LLM in a streaming format.
    // This RPC allows continuous streaming of responses from the model,
    // which is useful for real-time applications or large outputs.</p>
    rpc StreamingLlmGenerate (LlmGenerateRequest) returns (stream StreamingLlmGenerateResponse);

    // <p>Lists available Large Language Models (LLMs) for a specified CCAI service.
    // This RPC method allows clients to retrieve metadata about all LLM models associated
    // with a particular service within a project, including model names, descriptions, and providers.</p>
    rpc ListLlmModels (ListLlmModelsRequest) returns (ListLlmModelsResponse) {
        option (google.api.http) = {
            post: "/v2/{parent=projects/*/agent}/list_llm_models"
            body: "*"
        };
    }

}

// <p>The request message to list available LLM models for a specified CCAI service.</p>
message ListLlmModelsRequest {

    // The CCAI service for which to list models.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/ccai/services/&lt;service_uuid&gt;</code></pre>
    string ccai_service_name = 1;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 2;

}

// <p>The response message containing a list of available LLM models.</p>
message ListLlmModelsResponse {

    // <p>A list of LLM models associated with the specified CCAI service.
    // Each model in this list represents an individual language model that can
    // be used within the service, including details such as name, provider, and description.</p>
    repeated LlmModel llm_models = 1;

}

// <p>Represents an individual LLM model available within a CCAI service.</p>
message LlmModel {

    // <p>The resource name of the model.</p>
    // <p>Format: <pre><code>projects/&lt;project_uuid&gt;/ccai/services/&lt;service_uuid&gt;/model/&lt;model_uuid&gt;</code></pre></p>
    // <p>This is a unique identifier for the model, specifying its project, service, and model ID.</p>
    string name = 1;

    // <p>The display name of the model.</p>
    // <p>This is a human-readable name used for identifying the model in other requests,
    // such as <pre><code>LlmGenerateRequest</code></pre> and <pre><code>StreamingLlmGenerateRequest</code></pre>.</p>
    string display_name = 2;

    // <p>The description of the model.</p>
    // <p>Provides additional details about the model, such as its purpose, architecture, or any other relevant information.</p>
    string description = 3;

    // <p>The resource name of the CCAI service to which the model belongs.</p>
    // <p>This field links the model to its service context, helping clients understand
    // which service hosts the model.</p>
    string ccai_service_name = 4;

    // The provider of the CCAI service that offers this model.
    // Specifies the LLM provider (e.g., Ollama, OpenAI, Google, etc.), indicating the origin or vendor of the model.
    CcaiServiceProvider ccai_service_provider = 5;

}

// <p>The request message to generate a response from a Large Language Model (LLM).</p>
message LlmGenerateRequest {

    // <p>The request payload for the LLM, structured according to the specific
    // requirements of the large language model provider.</p>
    // <p>The payload must fit the format expected by the specified LLM provider,
    // as defined by <pre><code>CcaiServiceProvider</code></pre>.</p>
    google.protobuf.Struct llm_generation_request = 1;

    // The CCAI service to be used for processing the request.
    // This specifies which large language model provider and model settings will handle the request.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/ccai/services/&lt;service_uuid&gt;</code></pre>
    string ccai_service_name = 2;

    // Files as input for the generation request
    repeated FileResource file_resources = 3;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 4;

}

// <p>The response message containing the generated output from a Large Language Model (LLM).</p>
message LlmGenerateResponse {

    // The response data from the LLM, returned as a structured payload.
    // This can contain the text generation, embeddings, or other outputs
    // based on the specific request made to the LLM provider.
    google.protobuf.Struct llm_generation_response = 1;

    // Files as input for the generation request, e.g., generated pictures, audio or video
    repeated FileResource file_resources = 2;

}

// <p>The response message for streaming generation from a Large Language Model (LLM).</p>
message StreamingLlmGenerateResponse {

    // The response data from the LLM in a streaming format, returned as a structured payload.
    // This response is part of a continuous stream of data from the LLM, allowing
    // incremental results to be sent as they are generated.
    google.protobuf.Struct llm_generation_stream_response = 1;

}

// <p>The request to detect parameters.</p>
message ExtractEntitiesRequest {

    // the parent of the request
    // Format: <pre><code>projects/&lt;project_uuid&gt;</code></pre>
    string parent = 1;

    // the input text
    string text = 2;

    // the input language
    string language_code = 3;

    // Optional. The name of the relevant intent. Used to establish preference
    // hierarchy for entities that correspond to intent parameters
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent/intents/&lt;intent_uuid&gt;</code></pre>
    string intent_name = 4;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 5;

}

// <p>This message is a request to extract entities with Fuzzy Entity Recognizer</p>
message ExtractEntitiesFuzzyRequest {

    // the parent of the request
    // Format: <pre><code>projects/&lt;project_uuid&gt;</code></pre>
    string parent = 1;

    // The text to be analyzed
    string text = 2;

    // Potential entities to be extracted from the text with entity-specific configs
    repeated EntityTypeFuzzyNerConfig potential_entities = 3;

    // Minimal similarity score to consider entity as "matched"
    float minimal_score = 4;

    // Optional. Whether or not entities are allowed to overlap.
    bool allow_overlaps = 5;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 6;

}

// <p>Configuration for Fuzzy Entity Recognizer</p>
message EntityTypeFuzzyNerConfig {

    // The Entity Type
    EntityType entity_type = 1;

    // Optional. Overrides the minimal score in ExtractEntitiesFuzzyRequest.
    float minimal_score = 2;

    // Optional. If defined, only entity value from this list are considered.
    repeated string entity_values = 3;

    // Enum of fuzzy ner algorithms
    enum FuzzyNerAlgorithm {

        // <p>Levenshtein algorithm for fuzzy ner matching</p>
        PREFILTER_LEVENSHTEIN = 0;

        // <p>local maximum</p>
        LOCAL_MAXIMUM = 1;
    }
    // Optional. Specify the Fuzzy Ner algorithm
    FuzzyNerAlgorithm algorithm = 4;

    // Should not use allow_overlaps here, since its default value is False
    bool allow_overlaps = 5;

}

// <p>This message contains the entity detected</p>
message EntityDetected{

    // The entity name that is detected
    Intent.TrainingPhrase.Entity entity = 1;

    // The extractor name, e.g. SpacyNer
    string extraction_method = 2;

    // The confidence score of the detected entity
    float score = 3;

}

// <p>This message is a response of extracting entities</p>
message ExtractEntitiesResponse {

    // A list of entities detected
    repeated EntityDetected entities_detected = 1;

    // The text containing the entities detected
    string text = 2;

}

// <p>Request to get alternative sentences</p>
message GetAlternativeSentencesRequest {

    // Configuration type of the enricher
    DataEnrichmentConfig config = 1;

    // The sentence from which it is desired to get alternative sentences
    string sentence = 2;

    // Language code specifies the language of the request in IETF BCP 47 language tag format, e.g. de-DE, en-US, etc.
    string language_code = 4;

    // the parent of the request
    // Format: <pre><code>projects/&lt;project_uuid&gt;</code></pre>
    string parent = 5;

    // Protected words in the augmentation process
    repeated string protected_words = 6;

    // Words to be changed in the augmentation process
    repeated string words_to_change = 7;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 8;

}

// <p>Request to generate user sentences</p>
message GenerateUserSaysRequest {

    // language code specifies the language of the request in IETF BCP 47 language tag format, e.g. de-DE, en-US, etc.
    string language_code = 4;

    // the parent of the request
    // Format: <pre><code>projects/&lt;project_uuid&gt;</code></pre>
    string parent = 5;

    // The number of synonyms desired
    int32 n_repeat_synonym = 6;

    // Git branch
    string branch = 8;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 9;

}

// <p>Request to generate responses</p>
message GenerateResponsesRequest {

    // language code specifies the language of the request in IETF BCP 47 language tag format, e.g. de-DE, en-US, etc.
    string language_code = 4;

    // the parent of the request
    // Format: <pre><code>projects/&lt;project_uuid&gt;</code></pre>
    string parent = 5;

    // The number of synonyms desired
    int32 n_repeat_synonym = 7;

    // Git branch
    string branch = 8;

    bool drop_unknown_parameters = 9;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 10;

}

// <p>Request to get alternative training phrases</p>
message GetAlternativeTrainingPhrasesRequest {

    // Configuration of the enricher
    DataEnrichmentConfig config = 1;

    // Training phrase from which an alternative one is got
    Intent.TrainingPhrase training_phrase = 2;

    // The intent tag attached to the training phrase
    string intent_name = 3;

    // language code specifies the language of the request in IETF BCP 47 language tag format, e.g. de-DE, en-US, etc.
    string language_code = 4;

    // the parent of the request
    // Format: <pre><code>projects/&lt;project_uuid&gt;</code></pre>
    string parent = 5;

    // Flag to determine whether entities must or not be detected
    bool detect_entities = 6;

    // similarity threshold defines how similar sentences should be to drop generated training phrase
    // as duplicate. Meaningful values of similarity_threshold are between 0.95 and 1.0
    float similarity_threshold = 7;

    // Protected words in the augmentation process
    repeated string protected_words = 8;

    // Words to be changed in the augmentation process
    repeated string words_to_change = 9;

    // Git branch
    string branch = 10;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 11;

}

// <p>Request to get synonyms</p>
message GetSynonymsRequest {

    // Configuration of the enricher
    DataEnrichmentConfig config = 1;

    // Word from which a synonym is got
    string word = 2;

    // language code specifies the language of the request in IETF BCP 47 language tag format, e.g. de-DE, en-US, etc.
    string language_code = 4;

    // the parent of the request
    // Format: <pre><code>projects/&lt;project_uuid&gt;</code></pre>
    string parent = 5;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 6;

}

// <p>Response containing synonyms</p>
message GetSynonymsResponse {

    // A list of synonyms
    repeated Synonym synonyms = 1;
}

// <p>This message contains a Synonym</p>
message Synonym {

    // Synonym word
    string synonym = 1;

    // Score associated to the synonym resulted
    int32 score = 2;

}

// <p>Response containing alternative sentences</p>
message GetAlternativeSentencesResponse {

    // A list of alternative sentences
    repeated AltSentence alternative_sentences = 1;

}

// <p>Response containing responses</p>
message GenerateResponsesResponse {

    // A list of responses
    repeated string responses = 1;

}

// <p>Response containing user sentences</p>
message GenerateUserSaysResponse {

    // A list of sampled sentences
    repeated string user_says = 1;

}

// <p>Response containing alternative training phrases</p>
message GetAlternativeTrainingPhrasesResponse {

    // A list of alternative training phrases
    repeated AltTrainingPhrase alternative_training_phrases = 1;

}

// <p>This message contains an alternative sentence</p>
message AltSentence {

    // Alternative sentence
    string sentence = 1;

    // Score associated to the alternative sentence resulted
    float score = 2;

}

// <p>This message contains an alternative training phrase</p>
message AltTrainingPhrase {

    // Alternative training phrase
    Intent.TrainingPhrase training_phrase = 1;

    // Score associated to training_phrase
    float score = 2;

}

// <p>This message contains the configuration of data enrichment</p>
message DataEnrichmentConfig {

    // Entity augmenter configuration
    EntityEnrichmentConfig entity_enrichment = 1;

    // Thesaurus augmenter configuration
    ThesaurusEnrichmentConfig thesaurus_enrichment = 2;

    // Word2Vec augmenter configuration
    Word2VecEnrichmentConfig word2vec_enrichment = 3;

    // WordNet augmenter configuration
    WordNetAugEnrichmentConfig word_net_enrichment = 4;

    // GPT2 augmenter configuration
    GPT2EnrichmentConfig gpt2_enrichment = 5;

    // GloVe augmenter configuration
    GloVeEnrichmentConfig glove_enrichment = 6;

    // BERT augmenter configuration
    BertAugEnrichmentConfig bert_enrichment = 8;

    // XLNet augmenter configuration
    XLNetAugEnrichmentConfig xlnet_enrichment = 9;

    // Large language model (LLM) augmenter configuration
    LlmEnrichmentConfig llm_enrichment = 10;

}

// <p>Configuration for Entity enrichment</p>
message EntityEnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;

}

// <p>Configuration for Thesaurus enrichment</p>
message ThesaurusEnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;

}
// <p>Configuration for BERT augmenter enrichment</p>
message BertAugEnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;

}
// <p>Configuration for GloVe enrichment</p>
message GloVeEnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;

}

// <p>Configuration for GPT2 enrichment</p>
message GPT2EnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;

}

// <p>Configuration for Word2Vec enrichment</p>
message Word2VecEnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;
}

// <p>Configuration for WordNet augmenter enrichment</p>
message WordNetAugEnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;

}

// <p>Configuration for XLNet enrichment</p>
message XLNetAugEnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;

}

// <p>Configuration for large language model (LLM) enrichment</p>
message LlmEnrichmentConfig {

    // Activation flag
    bool is_active = 1;

    // Factor of enrichment
    int32 enrichment_factor = 2;

    // Order of augmenter execution
    int32 execution_order = 3;

    // The CCAI service to be used to enrich
    // This specifies which large language model provider and model settings will handle the request.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/ccai/services/&lt;service_uuid&gt;</code></pre>
    string ccai_service_name = 4;

}

// <p>The request for intent classification.</p>
message ClassifyIntentsRequest {

    // Required. The project of this agent.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent</code></pre>
    string parent = 1;

    // the input text
    string text = 2;

    // the input language
    string language_code = 3;

    // Optional: if restrict classification result with input contexts listed in the field <code>context_names</code>
    bool active_contexts = 4;

    // Optional: names of the input contexts to restrict the classification result with.
    // Intents can only be classified if the intent's input context set is the subset of the given context set.
    repeated string context_names = 5;

    // <p>Optional: Which mode to use:</p>
    // <ul>
    //   <li>EXCLUSIVE - skip algorithms listed in <code>algorithms</code> field,</li>
    //   <li>INCLUSIVE - run ONLY algorithms listed in <code>algorithms</code> field,</li>
    //   <li>UNSPECIFIED - default mode, described in agent config</li>
    // </ul>
    Mode mode = 6;

    // Optional: Algorithm list
    repeated IntentAlgorithms algorithms = 7;

    // Optional. The mask to control which fields gets returned.
    optional google.protobuf.FieldMask field_mask = 8;

}

// <p>Type of mode</p>
enum Mode {

    // <p>default mode, described in agent config</p>
    UNSPECIFIED = 0;

    // <p>skip algorithms listed in <code>algorithms</code> field,</p>
    EXCLUSIVE = 1;

    // <p>run ONLY algorithms listed in <code>algorithms</code> field</p>
    INCLUSIVE = 2;

}

// <p>Type of Intent algorithm.</p>
enum IntentAlgorithms {

    // <p>By enabling this, a specific intent is triggered if the context and the intent name in the user says is
    // matched. This can be used for directly triggering &apos;quick reply&apos; button clicks confidence is always &apos;1.0&apos;.</p>
    OndewoIntentExactContextDetector = 0;

    // <p>exact matching&apos; of user input to user says is used to detect the intent. Confidence is always &apos;1.0&apos; if an
    // &apos;exact match&apos; is found.</p>
    OndewoIntentExactMatch = 1;

    // <p>the entity synonym in the user says text is replaced by the entity and &apos;exact matching&apos; of user says text
    // is performed. Confidence is always &apos;1.0&apos;.</p>
    OndewoIntentNamedExactMatch = 2;

    // <p>the algorithm computes the similarity of the user input to all user says of all intents.</p>
    OndewoIntentSimilarityMatch = 3;

    // <p>the entity synonyms in the user says are replaced by their Entity. Text similarity algorithms are then
    // used to detect the intent.</p>
    OndewoIntentNamedSimilarityMatch = 4;

    // <p>new language representation model called BERT, which stands for Bidirectional Encoder Representations
    // from Transformers.BERT is designed to pre-train deep bidirectional representations by jointly conditioning
    // on both left and right context in all layers. As a result, the pre-trained BERT representations can be
    // fine-tuned for multi-class intent detection. For details see <a href="https://arxiv.org/abs/1810.04805">https://arxiv.org/abs/1810.04805</a></p>
    OndewoIntentBertClassifier = 7;

    OndewoIntentMetaClassifier = 8;

    // <p>Maximum number of repeated fallbacks before this algorithm exists the conversation and resets contexts</p>
    IntentExitDetector = 10;

    // <p>Algorithm to improve the interplay of the other algorithms</p>
    OndewoIntentRankingMatch = 11;

    // <p>Ensemble calculation of used algorithms</p>
    OndewoWeightedEnsemble = 13;

    // <p>Maximum number of repeated fallbacks before this algorithm exists the conversation and resets contexts</p>
    OndewoIntentExitDetector = 14;

    // <p>Matches the intent based on the parameter constellation and the current user context</p>
    OndewoIntentParameterMatch = 15;

}

// <p>Intent classified by a certain intent classifier</p>
message IntentClassified {

    // The unique identifier of this intent.
    // Format: <pre><code>projects/&lt;project_uuid&gt;/agent/intents/&lt;intent_uuid&gt;</code></pre>
    string intent_name = 1;

    // The name of the intent.
    string intent_display_name = 2;

    // The name of the classifier that detected the intent
    string classifier = 3;

    // Score associated to the detection of the intent by the classifier
    float score = 4;

}

// <p>Response containing the intents classified in a sentence</p>
message ClassifyIntentsResponse {

    // A list of intents detected
    repeated IntentClassified intents_classified = 1;

    // The text containing from which the intents were detected
    string text = 2;

    // Flag that enables the context through the conversation
    bool active_contexts = 3;

    // The context tags associated to the intents
    repeated string context_names = 4;

}
